# DDD实战

微服务架构是目前系统设计的主流架构，而DDD（domain-driven design，领域驱动设计）是设计一个优秀的微服务架构的指导思想，DDD的核心理念就是所有人员站在用户的角度、业务的角度去思考问题，而不是站在技术的角度去思考问题

## DDD的基本概念

### 领域与领域模型

* “领域”（domain）是一个比较宽泛的概念，主要指的是一个组织做的所有事情，比如一家银行做的所有事情就是银行的领域。
* 为了缩小讨论问题的范围，我们通常会把领域细分为多个“子领域”（简称“子域”），比如银行的领域就可以划分为“对公业务子域”“对私业务子域”“内部管理子域”等
* 子域还可以继续划分为更细粒度的子域，比如“对私业务子域”可以划分为“柜台业务子域”“ATM（automated teller machine，自动柜员机）业务子域”“网银业务子域”等
* 领域（包含子域）可以按照功能划分为核心域、支撑域、通用域。核心域指的是解决项目的核心问题的领域，支撑域指的是解决项目的非核心问题的领域，而通用域指的是解决通用问题的领域。核心域是和组织业务紧密相关的、个性化的领域，支撑域则具有组织特性，但不具有通用性，而通用域则是可以被很多其他领域复用的领域。
* 确定一个领域之后，我们就要对领域内的对象进行建模，从而抽象出模型的概念，这些领域中的模型就叫作领域模型（domain model），比如银行的柜台业务领域中，就有储户、柜员、账户等领域模型
* 建模是DDD中非常核心的事情，一旦定义出了领域模型，我们就可以用领域模型驱动项目的开发。使用DDD，我们在分析完产品需求后，就应该创建领域模型，而不是考虑如何设计数据库和编写代码，使用领域模型，我们可以一直用业务语言去描述和构建系统，而不是使用技术人员的语言

### 通用语言与界限上下文

* 在描述业务对象的时候，拥有确切含义的、没有二义性的语言是非常重要的，这样的语言就是“通用语言”
* 通用语言离不开特定的语义环境，只有确定了通用语言所在的边界，才能没有歧义地描述一个业务对象。比如，后台管理模块中的“用户”和支付模块的“用户”就处于不同的边界中，它们在各自的边界内有着各自的含义。界限上下文就是用来确定通用语言的边界的，在一个特定的界限上下文中，通用语言有着唯一的含义

### 实体类与值对象

* 在DDD中大量存在着这样一类对象，它们拥有唯一的标识符，标识符的值不会改变，而对象的其他状态则会经历各种变化，这样的对象可能会被持久化地保存在存储设备中，即使软件重启，我们也可以把持久化在存储设备中的对象还原出来，我们把这样的对象称为实体类（entity）。
* 标识符是用来跟踪对象状态变化的，一个实体类的对象无论经历怎样的变化，只要看到标识符的值没有变化，我们就知道它们还是那个对象
* 在具体实现DDD的时候，实体类一般的表现形式就是EF Core中的实体类，实体类的Id属性一般就是标识符，Id属性的值不会变化，它标识着唯一的对象，实体类的其他属性则可能在运行时被修改，但是只要Id不变，我们就知道前后两个对象指的是同一个对象。我们可以把实体类的对象保存到数据库中，也可以把它从数据库中读取出来。
* 在DDD中还存在着一些没有标识符的对象，它们也有多个属性，它们依附于某个实体类对象而存在，这些没有标识符的对象叫作值对象。同一个值对象不会被多个实体类对象引用；值对象一般是不可变的，也就是值对象的属性不可以修改
* 因此如果我们要修改实体类中的一个值对象属性，我们只能创建一个新的值对象来替换旧的值对象
* 比如，在电子地图系统中，“商家”就是一个实体类，该实体类包含营业执照编号、名称、经纬度位置、电话等属性。一个商家的营业执照编号是不可以修改的，而商家的名称、经纬度位置、电话都是可以修改的，只要两个商家的营业执照编号一样，我们就认定两个商家是同一家，因此营业执照编号就可以看作标识符。而经纬度位置就是一个值对象，经纬度位置这个值对象包含“经度”和“纬度”两个属性，经纬度位置没有标识符，而且经纬度位置的经度和纬度两个属性也不会被修改，如果商家搬家了，我们只要重新创建一个新的经纬度位置的对象，然后重新赋值商家的经度和纬度属性就可以了。当然，我们也可以取消经纬度位置这个值对象属性，直接改为经度、纬度两个属性，也就是商家实体类包含营业执照编号、名称、经度、纬度、电话等属性，但是把经度和纬度作为一个值对象更能够体现它们的整体关系
* 实体类帮助我们跟踪对象的变更，而值对象则帮助我们把多个相关属性当作一个整体

### 聚合与聚合根

* 我们可以把关系紧密的实体类放到一个聚合（aggregate）中，每个聚合中有一个实体类作为聚合根（aggregate root），所有对聚合内实体类的访问都通过聚合根进行，外部系统只能持有对聚合根的引用，聚合根不仅仅是实体类，还是所在聚合的管理者
* 聚合并不是简单地把实体类组合在一起，而要协调聚合内若干实体类的工作，让它们按照统一的业务规则运行，从而实现实体类数据访问的一致性，这样我们就能够实现聚合内的“高内聚”；聚合之间的关系很弱，一个聚合只能引用另外一个聚合的聚合根，这样我们就能够实现聚合间的“低耦合”
* 聚合体现的是现实世界中整体和部分的关系，比如订单与订单明细。整体封装了对部分的操作，部分与整体有相同的生命周期。部分不会单独与外部系统交互，与外部系统的交互都由整体来负责。
* 系统中很多实体类都存在着关系，这些关系到底是设计为聚合之间的关系还是聚合之内的关系是非常容易让人困惑的。判断的标准就是看它们是否是整体和部分的关系，是否存在着相同的生命周期，如果是的话，它们就是聚合内的关系，反之，则不是
* 比如，订单与订单明细之间显然是整体和部分的关系，因为删除了订单，订单明细也就消失了，而且外部系统不会直接引用订单明细，只会引用订单。因此我们把订单和订单明细设计为一个聚合，并且把订单作为聚合根，外部系统只能引用订单，对订单明细的操作都通过订单来进行
* 而用户和订单之间的关系就不是整体与部分的关系，因为删除了订单，用户还是可以存在的。有人可能会认为，删除了用户，这个用户的订单也就消失了，因此用户和订单是整体和部分的关系。但是聚合关系还有一个判断标准就是“实体类能否单独和外部系统交互”，很显然，在系统中订单是可以单独和外部系统交互的，比如支付系统中就可以直接引用订单，因此用户和订单之间不是聚合关系
* 有的情况下，聚合关系的划分也不是一成不变的，不同的业务流程决定了不同的划分方式。比如新闻和新闻的评论就既可以设计成同一个聚合，也可以放到不同的聚合中。如果在网站中，新闻和评论都是一起出现的，评论不会单独出现，我们就可以把它们设计成同一个聚合，把新闻设置为聚合根。但是如果在网站中，有“全站热门评论榜”“分享评论到朋友圈”等把评论作为一个独立的实体类看待的情况，我们就可以把新闻和评论设置为两个聚合
* 在设计聚合的时候，要尽量把聚合设计得小一点儿，一个聚合只包含一个聚合根实体类和密不可分的实体类，实体类中只包含最小数量的属性。小聚合有助于进行微服务的拆分，也有助于减少数据修改冲突。设计聚合的一个原则就是：聚合宁愿设计得小一点儿，也不要设计得太大
* 在实践中，一个微服务中可以包含多个聚合。由于聚合之间的关系都是聚合根之间的关系，因此耦合性低。当我们需要进行微服务架构演进的时候，我们就能以聚合为单位轻松地进行微服务的拆分了

### 领域服务与应用服务

* 聚合根的实体类中没有业务逻辑代码，只有对象的创建、对象的初始化、状态管理等与个体相关的代码
* 对于聚合内的业务逻辑，我们编写领域服务（domain service）
* 而对于跨聚合协作的逻辑，我们编写应用服务（application service）
* 应用服务协调多个领域服务来完成一个用例
* 领域服务不会涉及读写数据库的操作
* 业务逻辑放入领域服务，而与外部系统（数据库、缓存等）的交互由应用服务来负责。因为领域服务是用来协调领域对象完成业务逻辑操作的，所以领域服务是无状态的，状态由领域对象来管理
* 需要注意的是，领域服务不是必需的，在一些简单的业务处理（比如增、删、改、查）中是没有领域知识（也就是业务逻辑）的，这种情况下应用服务可以完成所有操作，不需要引入领域服务，这样我们可以避免系统出现过度设计的问题。如果随着系统的进化，应用服务中出现了业务逻辑，我们就要把业务逻辑放入领域服务
* 和聚合相关的两个概念是“仓储”（repository）和“工作单元”（unit of work）
* 聚合中的实体类不负责数据的读取和保存，这些工作是由仓储负责的，因此实体类负责业务逻辑的处理，仓储负责按照要求从数据库中读取数据以及把领域服务修改的数据保存回数据库，一个聚合对应一个用来实现数据持久化的仓储
* 聚合内数据操作的关系是非常紧密的，我们要保证事务的强一致性，而聚合间的协作是关系不紧密的，因此我们只要保证事务的最终一致性即可。聚合内的若干相关联的操作组成一个“工作单元”，这些工作单元要么全部成功，要么全部失败
* 领域服务不依赖外部系统、不保存状态

### 领域事件与集成事件

```c#
1  void 保存答案(long id,string answer)
2  {
3     long aId = 保存到数据库(id,answer);
4     发布事件("答案已保存",aId,answer);
5  }
6
7  [绑定事件("答案已保存")]
8  void 审核答案(long aId,string answer)
9  {
10    if(检查是否疑似违规(answer))
11    {
12       隐藏答案(aId);
13       发布事件("内容待审核",aId);
14    }
15 }
16
17 [绑定事件("答案已保存")]
18 void 发邮件给提问者(long aId,string answer)
19 {
20    long qId = 获取问题Id(aId);
21    string email = 获取提问者邮箱(qId);
22    发送邮件(email,"你的问题被回答了");
23 }
```

* 在我们对用户需求进行分析的时候，如果发现有“如果发生了某事，则执行某个动作”这样的描述的时候，我们都可以把它们通过事件机制来实现
* DDD中的事件分为两种类型：领域事件（domain events）和集成事件（integration events）
* 聚合内一般不需要通过领域事件进行事件传递，领域事件主要用于在同一个微服务内的聚合之间的事件传递
* 集成事件用于跨微服务的事件传递
* 比如在问答微服务中，当用户保存答案的时候，审核答案的逻辑我们一般通过领域事件实现。如果项目中有专门的邮件发送微服务，则当用户保存答案的时候，发送邮件给提问者的操作就要通过集成事件来实现

## DDD的技术落地

### 贫血模型与充血模型

* 所谓的贫血模型指的是一个类中只有属性或者成员变量，没有方法，而充血模型指的是一个类中既有属性、成员变量，也有方法
* 面向对象编程的基本特征是“封装性”：把类的内部实现细节封装起来（把领域知识封装到类的内部），对外提供可供安全调用的方法，从而让类的使用者无须关心类的内部实现

### EF Core对实体类属性操作的秘密

* 基于性能和对特殊功能支持的考虑，EF Core在读写属性的时候，如果可能，它会直接跳过get、set，而直接操作真正存储属性值的成员变量
* EF Core在读写实体类对象的属性时，会查找类中是否有与属性的名字一样（忽略大小写）的成员变量，如果有这样的成员变量的话，EF Core会直接读写这个成员变量的值，而不是通过set和get代码块来读写
* 如果我们采用`stirng Name{get;set;}`这种简化的语法来声明属性，编译器会为我们生成名字为`<Name>k__BackingField`的成员变量来保存属性的值，因此EF Core除了查找与属性同名的成员变量之外，也会查找符合`<Name>k__BackingField`规则的成员变量，还会查找`_name`,`m_name`等常见写法的成员变量
* EF Core会尝试按照命名规则去直接读写属性对应的成员变量，只有无法根据命名规则找到对应成员变量的时候，EF Core才会通过属性的get、set代码块来读写属性值
* 我们可以在Fluent API中通过`UsePropertyAccessMode`方法来修改这个默认的行为，不过这很少用

### EF Core中实现充血模型

* 充血模型中的实体类和POCO类相比，有如下的特征
  1. 属性是只读的或者只能被类内部的代码修改
  2. 定义了有参构造方法
  3. 有的成员变量没有对应属性，但是这些成员变量需要映射为数据库表中的列，也就是我们需要把私有成员变量映射到数据库表中的列
  4. 有的属性是只读的，也就是它的值是从数据库中读取出来的，但是我们不能修改属性值
  5. 有的属性不需要映射到数据列，仅在运行时被使用
* EF Core中的实体类如果没有无参构造方法，则有参构造方法中的参数的名字必须和属性的名字一致，因为在EF Core从数据库中加载数据的时候，它会用反射来调用有参构造方法以初始化实体类的对象。只有构造方法的参数名字和属性的名字一致，EF Core才知道构造方法中参数和数据库表的对应关系
* 要避免开发人员调用实体类的无参构造方法，保证EF Core能正确地从数据库中读取数据并赋值给实体类对象，我们有如下两种实现方式
  1. 实体类中可以定义无参构造方法，但是无参构造方法定义为private。由于开发人员无法直接调用私有的无参构造方法，而只能调用有参构造方法，这样就可以避免开发人员创建包含非法属性值的对象；EF Core可以调用私有构造方法，因此EF Core在从数据库中加载数据到实体类对象的时候，会调用这个私有构造方法创建实体类的对象，然后对各个属性进行赋值
  2. 实体类中不定义无参构造方法，只定义有意义的有参构造方法，但是要求构造方法中的参数的名字和属性的名字一致。无论是开发人员还是EF Core加载数据的时候，都调用这些有参构造方法来完成对象的初始化
* 第一种方式比较简单，而且对于有参构造方法的参数名等没有限制，但是这种方式存在着开发人员通过反射调用私有的无参构造方法来创建包含非法值对象的可能。第二种方式对开发人员和EF Core具有同样的限制，避免了第一种方式中通过反射来跳过限制的问题，不过它对于参数名字等的限制更加严格

### EF Core中实现值对象

* 在EF Core中，实体类的属性可以定义为枚举类型，枚举类型的属性在数据库中默认是以int类型来保存的。对于直接操作数据库的人员来讲，0、1、2这样的值没有“CNY”（人民币）、“USD”（美元）、“NZD”（新西兰元）等这样的string类型的值可读性强。EF Core中可以在Fluent API中用`HasConversion<string>`把枚举类型的值配置成字符串
* 从属实体类型并不要求必须为不可变类型，不过我们一般都把它们定义为不可变类型，这样能够提供更清晰的语义

### 千万不要面向数据库建模

* 在进行领域模型建模的时候，不考虑数据库，而是最后使用`Fluent API`来处理数据库实现的细节

### 聚合在.NET中的实现

* 上下文就是一个天然的仓储的实现
* 上下文会跟踪多个对象状态的改变，然后在`SaveChanges`方法中把所有的改变一次性提交到数据库中，这是一个“要么全部成功，要么全部失败”的操作，因此上下文也是一个天然的工作单元的实现
* 在 EF Core中，我们可以不为每个实体类都声明对应的DbSet类型的属性，即使一个实体类没有声明对应的DbSet类型的属性，只要EF Core遇到实体类对象，EF Core仍然会像对待其他实体类对象一样对其进行处理。
* 由于除了聚合根实体类之外，聚合中其他实体类不应该被开发人员访问到，因此我们可以在上下文中只为聚合根实体类声明`DbSet`类型的属性
* 由于聚合之间是松耦合关系，它们只通过聚合根的Id进行关联，因此所有跨聚合的数据查询都应该是通过领域服务的协作来完成的，而不应该直接在数据库表之间进行join查询。当然，对于统计、汇总等报表类的应用，则不需要遵循聚合的规范，我们可以通过执行原生SQL语句进行跨表的查询

### 用MediatR实现领域事件

### EF Core中发布领域事件的合适时机

### RabbitMQ的基本使用

* 信道（channel）：信道是消息的生产者、消费者和服务器之间进行通信的虚拟连接。为什么叫“虚拟连接”呢？因为TCP连接的建立是非常消耗资源的，所以RabbitMQ在TCP连接的基础上构建了虚拟信道。我们尽量重复使用TCP连接，而信道是可以用完就关闭的
* 队列（queue）：队列是用来进行消息收发的地方，生产者把消息放到队列中，消费者从队列中获取消息
* 交换机（exchange）：交换机用于把消息路由到一个或者多个队列中

### 整洁架构（洋葱架构）

* 在整洁架构中，不同的同心圆代表软件的不同部分，内层的部分比外层的部分更加抽象，也就是内层表达抽象，外层表达实现。外层的代码只能调用内层的代码，内层的代码可以通过依赖注入的形式来间接调用外层的代码。整洁架构这样的同心圆结构非常类似洋葱，因此又被称为“洋葱架构”
* 需要注意的是，整洁架构中的每一层并不一定直接对应代码中的一个项目，这些层之间是逻辑上的划分，在实际技术实现的时候，可能会出现一层的代码位于多个项目中、一个项目中包含多层的代码这样的情况
* 在进行项目开发的时候，我们除了要用到数据库之外，还会用到一些外部服务，比如我们要发送短信就要调用短信发送服务，要保存文件就要调用存储服务。这些外部服务实现的变化会比较频繁，甚至我们会进行服务供应商的切换。为了屏蔽这些服务实现的变化，我们把这些服务定义为接口，在内层代码中只定义和使用接口，在外层代码中定义接口的实现。这样我们在需要修改服务的实现的时候，只要修改外层代码中接口的实现代码即可，内层的代码不需要改动。这种对变化较大的外部服务进行屏蔽的层称为防腐层
