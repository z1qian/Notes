[TOC]

# 第一章 .NET应用程序和工具

## 1.2 .NET术语

### 1.2.1 .NET SDK

* `SDK` 中包含 `.NET` 命令行接口（`command-line interface,CLI`）、工具、库和运行库

* 我们可以安装 `.NET SDK` 的**多个**版本，可以使用 `dotnet --list-sdks` 命令显示系统上安装的所有不同版本的 `SDK`，默认情况下，将使用**最新版本**

* 如果不想使用最新版本的 `SDK`，可以通过 `dotnet new globaljson` 命令来创建 `global.json` 文件，将在当前目录中创建 `global.json` 文件，该文件包含 `version` 元素，其值为当前使用的版本号，你可以将这个版本号改为已安装的其他 `SDK` 版本

  ````json
  {
      "sdk":{
          "version":"5.0.202"
      }
  }
  ````

  在 `global.json` 的目录及其子目录中，将使用指定的 `SDK` 版本，使用 `dotnet --version` 命令来验证这一点

### 1.2.2 .NET运行库

* 在目标系统中，不需要安装 `.NET SDK`，只需要安装 `.NET` 运行库

* 运行库包含全部核心库和 `dotnet` 驱动程序

* 使用如下命令来查看系统上安装了哪些运行库

  ````bash
  dotnet --list-runtimes
  ````

### 1.2.3 公共语言运行库

* `C#` 编译器将 `C#` 代码编译为 `Microsoft Intermediate Language(IL)` 代码
* `IL` 代码由公共语言运行库 (`Common Language Runtime,CLR`) 运行
* `CLR` 把 `IL` 代码编译为原生代码，`.NET` 程序集中的 `IL` 代码由一个即时（`Just-In-Time，JIT`）编译器编译（包含在 `CLR` 中），该编译器创建平台特定的代码
* 运行库还包含一个带有**类型加载器**的类型系统，类型加载器负责从程序集中加载类型，类型系统中的安全基础设施验证是否允许使用某些类型系统结构，如继承
* 运行库的另一个特性是**垃圾收集器**，负责从**托管堆**中清除不在引用的对象的内存
* 运行库还负责线程的处理，在 `C#` 中创建托管的线程时，线程不一定来自底层的操作系统，运行库负责线程的虚拟化和管理

### 1.2.6 .NET Core

* `.NET Framework` 要求必须在系统上安装应用程序需要的特定版本，而在 `.NET Core` 中，框架（包括运行库）是与**应用程序一起交付的**
* `.NET Core` 以**模块化**的方式设计。该框架分成数量很多的 `NuGet` 包
* 从 `.NET 5` 开始，`.NET Core` 有了一个新的名词：`.NET`

### 1.2.8 .NET Standard

* `.NET Standard` 不是一个实现，而是一个协定，本协定规定了需要实现哪些 `API`
* 从 `.NET 5` 开始，`.NET Standard` 变得不再重要，如果你使用 `.NET 5` 创建库，可以在 `.NET 5` ，`.NET 6` 及更高版本的应用程序中使用这些库

###  1.2.9 NuGet包

* `NuGet` 包是一个 `zip` 文件，其中包含程序集（或多个程序集），配置信息和 `PowerShell` 脚本

* 可以使用 `.NET CLI` 在应用程序中添加 `NuGet` 包

  ````bash
  dotnet add package <package-name>
  ````

## 1.6 使用.NET CLI

### 1.6.1 创建应用程序

命令：`dotnet new <template> --output <filepath>`

``` 
“dotnet new”命令基于模板创建 .NET 项目。

常用模板包括:
模板名                 短名称        语言        标记
---------------------  ------------  ----------  -------------------
ASP.NET Core Web 应用  webapp,razor  [C#]        Web/MVC/Razor Pages
Blazor Server 应用     blazorserver  [C#]        Web/Blazor
Windows 窗体应用       	winforms      [C#],VB     Common/WinForms
WPF 应用程序           	wpf           [C#],VB     Common/WPF
控制台应用              console       [C#],F#,VB  Common/Console
类库                   classlib      [C#],F#,VB  Common/Library

例如:
   dotnet new console

通过以下方式显示模板选项:
   dotnet new console -h
通过以下方式显示已安装的所有模板:
   dotnet new list
通过以下方式显示 NuGet.org 上可用模板:
   dotnet new search web
```

### 1.6.2 顶级语句

```c#
using System;
Console.WriteLine("Hello World!");
```

* `C# 9` 让我们能够简化 `Hello World` 应用程序的代码
* 使用顶级语句时，仍然会在后台生成一个类和一个 `Main` 方法

### 1.6.3 选择框架和语言版本

* `TargetFrameworks` 指定多个目标框架，`LangVersion` 定义使用的 `C#` 版本

  ```json
  <Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
      <TargetFrameworks>net6.0;net48</TargetFrameworks>
      <LangVersion>9.0</LangVersion>
    </PropertyGroup>
  </Project>
  ```
  
* 不需要手动把源文件添加到项目中，相同目录和子目录中，带有 `.cs` 扩展名的文件会自动添加到项目中进行编译，还会自动添加带有 `.resx` 扩展名的资源文件，用于嵌入资源

* 不需要手动添加 `.Net Core` 包，当指定目标框架 `.NET 5.0` 的时候，将自动包含元包 `Microsoft.NETCore.App` ，它引用了其他许多包

### 1.6.4 构建应用程序

* 要构建应用程序，需要**将当前目录改为应用程序的目录**，并启动  `dotnet build`

* 要**构建发布代码**，就需要指定选择 `--configuration Release` （简写为 `-c Release`）

  ```bash
  dotnet build --configuration Release
  ```
  
* 命令 `dotnet new` 和 `dotnet build` 会自动恢复 `NuGet` 包，这可以防止忘记恢复包，也可以使用 `dotnet restore` 显示地恢复 `NuGet` 包

### 1.6.5 运行应用程序

* 命令： `dotnet run`

  * 如果项目文件面向多个框架，就需要通过 `--framework` 选项告诉 `dotnet run` 命令，使用哪个框架来运行应用程序<span style="color:red">（这个框架必须通过 csproj 文件来配置）</span>

* 在生产系统中，不使用 `dotnet run` 运行应用程序，而是使用 **dotnet 和库的名称**：`dotnet bin/debug/net5.0/HelloWorld.dll`
* 可执行文件的作用只是**加载和启动库**

### 1.6.6 创建 Web 应用程序

命令：`dotnet new webapp -o WebApp`

* 会使用 `Razor Pages` 创建新的 `ASP.NET Core Web` 应用程序
* 创建的项目文件现在包含对 `Microsoft.NET.Sdk.Web SDK` 的引用，该 `SDK` 包含创建 `Web` 应用程序和服务时需要用到的工具和扩展

### 1.6.7 发布应用程序

#### 依赖于框架的部署

使用 `-f` 选择框架，使用 `-c` 选择发布配置

```bash
dotnet publish -f net5.0 -c Release
```

#### 自包含部署

1. 不在目标系统上安装运行库，而是在**交付应用程序时一起交付运行库**

2. 安装应用程序的平台不同，运行库就不同，因此，需要通过在项目文件中指定 `RuntimeIdentifiers` 来指定支持的平台

   ```bash
   <RuntimeIdentifiers>
   	win10-x64; ubuntu-x64; osx.10.11-x64;
   </RuntimeIdentifiers>
   ```

3. 为所有不同的平台创建发布文件

   ```bash
   dotnet publish -c Release -r win10-x64
   dotnet publish -c Release -r osx.10.11-x64
   dotnet publish -c Release -r ubuntu-x64
   ```

### 1.6.9 创建单个可执行文件

添加 `-p:PublishSingleFile=true` 选项，会把整个运行库添加到一个二进制文件中，然后可以将该文件用于部署

```bash
dotnet publish -r win10-x64 --self-contained -o <filepath> -p:PublishSingleFile=true
```

### 1.6.10 readytorun

为了**提高应用程序的启动性能**，可以将应用程序的一部分预编译为原生代码，这样一来，在运行应用程序的时候，`IL` 编译器要做的工作就减少了

```bash
dotnet publish -c Release -r win-x64 -p:PublishReadyToRun=true
```

还可以在项目文件中指定 `<PublishReadyToRun>` 元素

```bash
<PropertyGroup>
  <PublishReadyToRun>true</PublishReadyToRun>
</PropertyGroup>

dotnet publish -c Release -r win-x64
```

### 1.6.11 裁剪

* 发布应用程序时在一个可执行文件中包含完整的运行库会导致文件太大，可以通过这种方法解决：裁剪掉应用程序不需要的类和方法，使二进制文件变得更小

* 通过在项目文件中指定 `PublishTrimmed` 元素，可以启用裁剪

  ```bash
  <PublishTrimmed>true</PublishTrimmed>
  <TrimMode>link</TrimMode>
  ```

* `TrimMode` 指定了裁剪的程度

  * `link` 基于成员进行裁剪，删除掉未使用的成员
  * `copyused` 如果应用程序使用了一个程序集中的任何成员就完整保留该程序集

* 通过使用下面的命令和上面的项目配置，可以创建一个应用了裁剪的可执行文件

  ```bash
  dotnet publish -o <filepath> -p:PublishSingleFile=true --self-contained
  ```

* 裁剪存在风险。例如，如果应用程序使用了反射，那么裁剪器不知道运行时需要反射成员。为了应对这种问题，可以指定不裁剪哪些程序集、类型和类型成员。要配置这些选项，请在 [以下网站](https://learn.microsoft.com/zh-cn/dotnet/core/deploying/trimming/trimming-options) 阅读详细的文档

# 第二章 核心C#

## 2.1 C# 基础

`C#` **区分大小写**，即 `myVar` 与 `MyVar` 是两个不同的变量

### 2.1.4 变量的作用域

无论在什么地方声明变量，编译器都会将所有变量声明**移动到作用域内的顶部**

```c#
for (int i = 0; i < 10; i++)
{
    //Cat't do this -j is still in scope
    int j = 30;
    Console.WriteLine(j + i);
}

int j = 20;
```

### 2.1.5 常量

* 使用 `const` 关键字声明变量后，在该变量出现的每个地方，编译器将使用常量值替换它
* 常量必须在**声明时初始化**，指定了其值后，就**不能再改写了**
* 常量的值必须能在**编译时计算出来**，因此，不能用变量的值来初始化常量
* 常量总是**隐式静态**的，不允许在常量声明中包含修饰符 `static`

## 2.2 可空类型

### 2.2.1 可空值类型

* `int? x1 = null;` 编译器将把这行语句改为使用 `Nullable<T>` 类型：`Nullable<int> x1 = null;`
* `Nullable<T>` 不会增加引用类型的开销，它仍然是一个 **`struct`（值类型）**，只不过添加了一个布尔标志，用来指定值是否为 `null`

### 2.2.2 可空引用类型

* 可空引用类型的目标是**减少 `NullReferenceException` 类型的异常**

* 需要在项目文件中指定 `Nullable` 元素，并将其值设置为 `enable`：`<Nullable>enable</Nullable>`

  * `string s1 = null;` 编译器将给出警告

* ```c#
  string? s1 = null;
  
  //string s2 = s1.ToUpper();   //compiler warning
  
  string? s2 = s1?.ToUpper();
  
  string s3 = s1?.ToUpper() ?? string.Empty;
  ```

  * null条件运算符`?.`，可以在调用方法前检查 `null`，使用该运算符时，只有对象不为 `null`，才会调用方法，否则，则右侧表达式的结果为 `null`
  * 空合并运算符`??`，可以在对象为 `null` 时指定一个不同的返回值

* 还可以使用 `C#` 模式 `is not` 或 `! =` 来验证不为 `null`

  ```c#
  if (s1 is not null)
  
  if (s1 != null)
  ```

* Nullable reference types have **Nullable attributes** associated.（可空引用类型关联着 `Nullable attributes` ）

## 2.3 使用预定义数据类型

* 数据类型的 `C#` 关键字（如 `int`，`short` 和 `string`）由编译器映射为 `.NET` 数据类型，例如，在 `C#` 中声明一个 `int` 类型的数据时，声明的实际上时 `.NET struct`（`System.Int32`）的一个实例

* 所有基本数据类型都提供了可供调用的方法，例如要把 `int i` 转换为 `string` 类型可以编写下面的代码

  ```c#
  string s = i.ToString();
  ```

  应该强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。因此，基本类型用 `C#` 结构表示，实际上并没有性能损失

### 2.3.1 整型

**描述**:介绍了整数（byte，sbyte，short，ushort，int，uint，long，ulong）与 .NET 数据类型的对应关系，比如：C# 关键字 sbyte 映射到 .NET 数据类型 System.SByte，及各个整数类型使用的位数，比如：short 和 ushort 类型使用 16 位

### 2.3.2 BigInteger

* 如果需要的数字比 64 位的 long 类型能够表示的值更大，则可以使用 BigInteger 类型
* 该结构对于**位数没有限制**，可以一直增长下去，直到没有可用的内存
* 这个类型的没有对应的 C# 关键字，所以需要使用 BigInteger
* 因为它能无限增长，所以无法提供 MinValue 和 MaxValue 属性

### 2.3.3 本机整数类型

C#9 为平台特定的值提供了新的关键字：nint 和 nuint（分别代表本机整数和本机无符号整数）在 64 位应用程序中，这些整数类型使用 64 位，而在 32 位应用程序中，只使用32位

### 2.3.4 数字分隔符

* 为了提高数字的可读性，可以使用数字分隔符 `long l1 = 0x_123_4567_89ab_cedf;`
* 用作分隔符的下划线被编译器**忽略**，这些分隔符提高了可读性，但并没有添加任何功能
* 可以在任何位置放置下划线

### 2.3.5 二进制值

二进制值中也可以使用数字分隔符：`uint binary1 = 0b_1111_1110_1101_1100_1011_1010_1001_1000;`

### 2.3.6 浮点类型

| C#关键字 |   .NET 类型   |       说明        | 有效位数 | 指数位数 |
| :------: | :-----------: | :---------------: | :------: | :------: |
|          |  System.Half  | 16 位单精度浮点数 |    10    |    5     |
|  float   | System.Single | 32 位单精度浮点数 |    23    |    8     |
|  double  | System.Double | 64 位双精度浮点数 |    52    |    11    |

.NET 有一个高精度的浮点类型：decimal 类型（.NET 结构 Decimal），它使用 128 位，可用于**财务计算**，在这 128 位中有 1 位用作符号，96 位用作整数，剩下的位数指定了比例因子：`decimal d = 12.30M;`

### 2.3.7 bool 类型

bool 值和整数值不能相互隐式转换。如果变量（或函数返回类型）声明为 bool 类型，就只能使用值 true 或 false。如果试图使用 0 表示 false，非 0 值表示 true 就会出错

### 2.3.8 字符类型

#### char 的表现形式

|           形式            |  举例值  |
| :-----------------------: | :------: |
|        字符字面量         |   'A'    |
| 4 位 16 进制的 Unicode 值 | '\u0041' |
| 带有强制类型转换的整数值  | (char)65 |
|         16 进制数         | '\x0041' |
|         转义序列          |   '\n'   |

### 2.3.9 数字的字面值

| 字面值 | 位置 |             说明              |
| :----: | :--: | :---------------------------: |
|   U    | 后缀 |         unsigned int          |
|   L    | 后缀 |             long              |
|   UL   | 后缀 |         unsigned long         |
|   F    | 后缀 |             float             |
|   M    | 后缀 |        decimal（货币）        |
|   0x   | 前缀 |  十六进制数字，允许使用 0~F   |
|   0b   | 前缀 | 二进制数字，只允许使用 0 和 1 |
|  true  |  NA  |            布尔值             |
| False  |  NA  |            布尔值             |

### 2.3.10 object类型

Object 类是所有引用类型最终的基类，它可以用于两个目的：

* 可以使用 object 引用来绑定任何特定子类型的对象
* object 类型实现了许多一般用途的基本方法，包括 Equals()，GetHashCode()，GetType()，Tostring()。用户定义的类可能需要使用一种面向对象技术**重写**来提供其中一些方法的替代实现代码

## 2.4 程序流控制

### 2.4.2 is 运算符的模式匹配

```c#
if (o is null)	// const pattern
    
if(o is not null)	// const pattern

if (o is int i)	// type pattern
```

### 2.4.3 switch 语句

* switch...case 语句适合于从一组**互斥**的可执行分支中选择一个执行分支
* case 值必须是**常量表达式**，不允许使用变量

### 2.4.4 switch 语句的模式匹配

```c#
void SwitchWithPatternMatching(object? o)
{
    switch (o)
    {
        case null:
            Console.WriteLine("const pattern with null");
            break;
        case int i when i > 42:
            Console.WriteLine("type pattern with when clause and a relational pattern");
            break;
        case int:
            Console.WriteLine("type pattern with an int");
            break;
        case Book b:
            Console.WriteLine($"type pattern with a Book {b.Title}");
            break;
        default:
            break;
    }
}
```

* `case null` 是一个常量模式，将 o 与 null 进行比较
* `case int i` 使用了类型模式，当 o 是 int，并且 when 子句满足时，就会创建变量 i
* `when` 子句使用关系模式检查他是不是大于 42

### 2.4.5 switch 表达式

* 可以直接在 case 中返回一个值而不继续执行其余 case

  * switch 语句

    ```c#
    TrafficLight NextLightClassic(TrafficLight light) 
    {
        switch (light)
        {
            case TrafficLight.Green:
                return TrafficLight.Amber;
            case TrafficLight.Amber:
                return TrafficLight.Red;
            case TrafficLight.Red:
                return TrafficLight.Green;
            default:
                throw new InvalidOperationException();            
        }
    }
    ```

  * switch 表达式

    ```c#
    TrafficLight NextLightClassic(TrafficLight light) =>
        light switch
        {
            TrafficLight.Green => TrafficLight.Amber,
            TrafficLight.Amber => TrafficLight.Red,
            TrafficLight.Red => TrafficLight.Green,
            _ => throw new InvalidOperationException()
        };
    ```

* 模式组合符

  ```c#
  string? input = Console.ReadLine();
  
  string result = input switch
  {
      "one" => "the input has the value one",
      "two" or "three" => "the input has the value two or three",
      _ => "any other value"
  };
  ```

  使用模式组合符时，可以使用 and，or 和 not 关键字组合模式

### 2.4.9 foreach 循环

* foreach 循环**不能改变**集合中各项的值

  ```c#
  foreach (int temp in arrayOfInts)
  {
      temp++;
  
      Console.WriteLine(temp);
  }
  ```

* 如果需要迭代集合中的各项，并改变它们的值，应使用 for 循环

## 2.5 名称空间

* 在定义名称空间时，可以采用分层的方式

  ```c#
  namespace Wrox
  {
      namespace ProCSharp
      {
          namespace CoreCSharp
          {
              public class Sample
              {
              }
          }
      }
  }
  
  或者
      
  namespace Wrox.ProCSharp.CoreCSharp;
  public class Sample
  {
  }
  ```

* 名称空间是一种**逻辑构造**，完全独立于物理文件或组件，它是将不同类型分组到一起的一种逻辑构造

### 2.5.2 名称空间的别名

```c#
using TimersTimer = System.Timers.Timer;
using WebTimer = System.Web.UI.Timer;
```

## 2.6 使用字符串

string 是不可变的，它提供的所有方法不改变字符串的内容，而是返回一个新的字符串

### 2.6.1 使用 StringBuilder

* StringBuilder 允许程序使用 Append()，Insert()，Remove() 和 Replace() 方法动态操作字符串，并不会创建新的对象
* StringBuilder 会使用一个内存缓冲区，在需要的时候修改这个缓冲区
* 创建 StringBuilder 时，默认容量为 16 个字符，如果容量太小，需要增加时，缓冲区大小总是**成倍增加**

### 2.6.2 字符串插值

* `string s2 = $"Hello，{s1}!"` 在花括号内，可以编写代码表达式，这些表达式将被计算，其结果将被添加到字符串中

  ```c#
  string s3 = $"The result of {x} and {y} is {x + y}";
  ```

* 编译器会翻译插值字符串，以**调用 string 的 Format() 方法**

==Warring：要在插值字符串中转义花括号，可以使用双花括号：{{}}==

### 2.6.3 FormattableString

`FormattableString s = $"The result of {x} + {y} is {x + y}";`

```c#
int x = 3, y = 4;
FormattableString s = $"The result of {x} + {y} is {x + y}";
Console.WriteLine($"format：{s.Format}");

for (int i = 0; i < s.ArgumentCount; i++)
{
    Console.WriteLine($"argument：{i}：{s.GetArgument(i)}");
}
```

> format：The result of {0} + {1} is {2}
> argument：0：3
> argument：1：4
> argument：2：7

### 2.6.4 字符串格式

对于插值字符串，可以为表达式添加一个字符串格式，.NET 基于计算机的区域为数字，日期和时间定义了默认格式

```c#
DateTime day = new(2025, 2, 14);
Console.WriteLine($"{day:D}");
Console.WriteLine($"{day:d}");

int i = 2477;
Console.WriteLine($"{i:n} {i:e} {i:x} {i:c}");

double d = 3.1415;
Console.WriteLine($"{d:###.###}");
Console.WriteLine($"{d:000.000}");
```

> 2025年2月14日
> 2025/2/14
> 2,477.00 2.477000e+003 9ad ￥2,477.00
> 3.142
> 003.142

| 格式说明符 |             说明              |
| :--------: | :---------------------------: |
|     D      |      长日期格式显示日期       |
|     d      |      短日期格式显示日期       |
|     n      |          整数加小数           |
|     e      |          指数表示法           |
|     x      |         十六进制格式          |
|     c      |           货币格式            |
|  ###.###   | 将小数点后的位数四舍五入为3位 |
|  000.000   |      小数点前面也显示3位      |

> 1. [数字的不同格式字符串的信息](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/standard-numeric-format-strings)
> 2. [日期/时间的不同格式字符串的信息](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/standard-date-and-time-format-strings)

### 2.6.5 verbatim 字符串

描述：显示原始字符串，不进行转义

```c#
string s = @"a tab: \t, a carriage return: \r, a newline: \n";
```

> a tab: \t, a carriage return: \r, a newline: \n

### 2.6.6 字符串范围

* 范围运算符使用 “..” 表示法来指定一个范围
* 在字符串中，可以使用索引器（[]）来访问一个字符，或者可以将其与范围运算符结合使用，以访问一个子串
* “..” 运算符左右两侧的数字指定了范围
  * 左侧的数字指定了从字符串取出的第一个值（从零开始索引），它包含在范围内
  * 右侧的数字指定了从字符串中取出的最后一个值（也是从零开始索引）
* 要从字符串末尾开始算起，可以使用 hat 运算符 “^”

```c#
string s = "The1quick2brown fox jumped over the lazy dogs down " +
       "1234567890times";

string the = s[..3];
string quick = s[4..9];
string time = s[^5..^1];
```

> The
> quick
> time

## 2.7 注释

### 2.7.1 源文件中的内部注释

内联注释：`DoSomething(Width, /*Height*/ 100);`

### 2.7.2 XML 文档

|      标记      |                       说明                       |
| :------------: | :----------------------------------------------: |
|      <c>       |  把行中的文本标记为代码，例如<c>int i = 10;</c>  |
|     <code>     |                 把多行标为为代码                 |
|   <example>    |                 标记一个代码示例                 |
|  <exception>   |       说明一个异常类（编译器要验证其语法）       |
|   <include>    | 包含其他文档说明文件的注释（编译器要验证其语法） |
|     <list>     |                 把列表插入文档中                 |
|     <para>     |                  建立文本的结构                  |
|    <param>     |       标记方法的参数（编译器要验证其语法）       |
|   <paramref>   |  表明一个单词是方法的参数（编译器要验证其语法）  |
|  <permission>  |      说明对成员的访问（编译器要验证其语法）      |
|   <remarks>    |                  给成员添加描述                  |
|   <returns>    |                 说明方法的返回值                 |
|     <see>      | 提供对另一个参数的交叉引用（编译器要验证其语法） |
|   <seealso>    |   提供描述中的“参加”部分（编译器要验证其语法）   |
|   <summary>    |             提供类型或成员的简短小结             |
|  <typeparam>   |     用在泛型类型的注释中，以说明一个类型参数     |
| <typeparamref> |                  类型参数的名称                  |
|    <value>     |                     描述属性                     |

要生成 XML 文档，可以在项目文件中添加 `GenerateDocumentationFile` 元素，添加了这个设置后，将在编译应用程序的时候在程序的二进制文件目录中生成文档文件，也可以指定 `DocumentationFile` 元素，指定生成文档文件的名称和绝对路径

```c#
<PropertyGroup>
	<GenerateDocumentationFile>true</GenerateDocumentationFile>
    <DocumentationFile>e:\1.xml</DocumentationFile>
</PropertyGroup>
```

## 2.8 C# 预处理器指令

* 这些命令从来不会转换为可执行代码中的命令，但会**影响编译过程**的各个方面
* 预处理器指令的开头都有符号#
* 预处理器指令不用分号结束，一般一行上只有一条命令。如果编译器遇到一条预处理器指令，就会假定下一条命令在下一行

### 2.8.1 #define 和 #undef

#### #define

* `#define DEBUG` 告诉编译器存在给定名称的符号，在本例中是 DEBUG，这个符号不是实际代码的一部分，而只是在编译器**编译代码时存在**

#### #undef

* `#undef DEBUG` 删除符号的定义

#### 总结

* 如果符号不存在，#undef 就没有任何作用
* 如果符号已存在，则 #define 也不起作用
* 必须把 #define 和 #undef 命令放在 C# 源文件的**开头位置**，在声明要编译的任何对象的代码之前
* 默认情况下，在调试构件中，已存在 DEBUG 符号，而在发布代码中，已存在 RELEASE 符号

### 2.8.2 #if，#elif，#else 和 #endif

```c#
int DoSomeWork(double x)
{
#if DEBUG
    Console.WriteLine($"x is {x}");
#endif
}
```

```c#
#define ENTERPRISE
#define W10

#if ENTERPRISE
Console.WriteLine("ENTERPRISE");
#if W10
Console.WriteLine("ENTERPRISE And W10");
#endif
#elif PROFESSIONAL
Console.WriteLine("PROFESSIONAL");
#else
Console.WriteLine("Nothing");
#endif
```

* 这些指令告诉编译器是否要编译代码块，称为条件编译

* #if 和 #elif 还支持一组逻辑运算符 !，==，！=，&&，||，如果符号存在，就被认为是 true，否则为 false

  ```c#
  #if W10 && !ENTERPRISE // if W10 is defined but ENTERPRISE isn't
  ```

### 2.8.3 #warning 和 #error

* #warning 会向用户显示 #warning 指令后面的文本，之后编译**继续进行**
* #error 会向用户显示后面的文本，作为一条编译错误消息，然后会立即**退出编译**，不会生成 IL 代码

### 2.8.4 #region 和 #endregion

* 用于把一段代码视为有给定名称的一个块
* 编译器会忽略 region 指令，但 Visual Studio 代码编辑器等工具会使用该指令
* 编译器允许折叠 region 部分，只显示与该 region 关联的文本名称

### 2.8.5 #line

* 用于改变编译器在警告和错误信息中显示的**文件名**和**行号**信息
* `#line default` 用于把行号还原为默认的行号

### 2.8.6 #pragma

```c#
#pragma warning disable 169
public class MyClass
{
    int neverUsedField;
}
#pragma warning restore 169
```

* 可以抑制或还原指定的编译警告
* 可以在类或方法级别实现，对抑制警告的内容和抑制的时间进行更精细的控制

### 2.8.7 #nullable

* 可以启用或禁用代码文件内的可空引用类型
* 无论项目文件中指定什么设置，`#nullable enable` 都将启用可用引用类型，`#nullable disable` 禁用可空引用类型，`#nullable restore` 将设置改回项目文件中的设置

## 2.9 C# 编程准则

### 2.9.1 关于标识符的规则

* 标识符是给变量，用户定义的类型（如类和结构）和这些类型的成员指定的**名称**

* **标识符区分大小写**，所以 interestRate 和 InterestRate 是不同的变量

* 确定在 C# 中可以使用什么标识符有两条规则

  * 可以包含数字字符，但数字字符必须以字母或下划线开头
  * 不能把 C# 关键字用作标识符

* 如果需要把某一保留字用作标识符（例如，访问一个用另一种语言编写的类），那么可以在标识符的前面加上前缀符号 @ ，告知编译器其后的内容是一个标识符，而不是 C# 关键字

  ```c#
  int @int=10;
  ```

* 标识符也可以包含 Unicode 字符，用语法 `\uXXXX` 指定，其中 XXXX 是 Unicode 字符的 4 位十六进制编码

  ```c#
  string _Identifier;
  string \u005fIdentifier;
  ```

  * 这两个标识符完全相同，可以互换，因为 005f 是下划线字符的 Unicode 代码
  * 所以这两个标识符在同一个作用域内不能声明两次

### 2.9.3 命名约定

名称应**反应数据项的目的**，且不与其他名称冲突，例如：`int height`

#### 1. 名称的大小写

* 名称空间和类，以及基类中的成员等名称都应遵循 Pascal 大小写规则（`EmployeeSalary`），最好不要使用带下划线字符的单词（`employee_salary`）

* 常量的名称应全部使用 Pascal 大小写形式的命名约定：`const int MaximumLength;`

* 可以使用 camel 大小写形式（`employeeSalary`）：

  * 类型中所有私有成员字段的名称（从 .NET Core 开始，.NET 团队在私有成员字段的名称前面添加了下划线作为前缀 `private readonly FSDbContext _dbContext;`）

  * 传递给方法的所有参数的名称

  * 用于区分同名的两个对象

    ```c#
    private string employeeName;
    public string EmployeeName
    {
        get { return employeeName; }
    }
    ```

#### 2. 名称的风格

* 名称的风格应保持一致，例如：如果类中的一个方法名为 `ShowConfirmationDialog()`，另一个方法就不能被命名为 `ShowDialogWarning()` 或 `WarningDialogShow`，而应该是 `ShowWarningDialog()`

### 2.9.5 字段的使用

字段几乎总应该是私有的，但在某些情况下也可以把**常量**或**只读字段**设置为公有

# 第三章 类，记录，结构和元组

## 3.2 按值传递和按引用传递^（p57）^

* .NET 中的类型可分为**按值传递**和**按引用传递**的类型

* 引用类型，例如类，数据存储在**托管堆**上的内存中，变量本身存储在栈上，但它引用堆上的内容

* 值类型，例如结构，数据通常存储在**栈**上

* 如果不再使用堆上的对象，垃圾收集器需要清理这些对象，而栈上的内存会在方法结束后自动释放，因为此时变量超出了其作用域

* C# 9 记录（`record`）就是一个类

* 使用元组时，可以把多个类型组合为一个类型，而不需要创建类、结构或记录

* 在为元组使用 C# 语法时，编译器在后台会使用 `ValueTuple` 类型（**这是一个结构**）并复制值

  ```c#
  var t1 = (Number: 1, String: "a");
  var t2 = t1;
  t2.Number = 2;
  t2.String = "b";
  Console.WriteLine($"original didn't change with a tuple: {t1.Number} {t1.String}");
  ```

  > original didn't change with a tuple: 1 a

## 3.3 类^（p59）^

* 类包含成员，成员可以是静态成员或实例成员，**静态成员属于类，实例成员属于对象**，静态成员关联了 static 修饰符
* 成员的种类见表 3-1^（p59）^
  * 字段
  * 常量
  * 方法
  * 属性
  * 构造函数
  * 索引器
  * 运算符（运算符重载）
  * 事件
  * 析构函数
  * 解构函数（允许将对象解构为元组或不同的变量）
  * 类型（类可以包含内部类）

### 3.3.1 字段^（p60）^

* 字段是与类关联的变量

* 静态字段的值对每个对象都是相同的，而每个对象的实例字段都可以有不同的值
* 对类本身应用 `static` 修饰符，编译器会确保不会在该类中添加实例成员

### 3.3.2 只读字段^（p60）^

`private readonly string _firstName;`

#### 与 const 修饰符的不同

const 是静态常量，是**编译时常量**；readonly 是动态常量，是**运行时常量**，const 较高效，readonly 较灵活

1. 访问方式
   * const 字段总是隐式静态的，只能由类型来访问，**不能与 static 同时使用**
   * readonly 字段可以是实例成员，由实例对象来访问，可以显示使用 static 定义为静态成员

2. 修饰内容

   * const 只能应用在值类型（包括 string 类型），但不能用 new 关键字初始化；其他引用类型 const 变量只能定义为 null
   * readonly 可以应用在任意类型，但是 readonly 赋值引用类型以后，引用本身不可以改变，但是引用所指向的实例的值是可以改变的

3. 初始化

   * const 必须在字段声明时初始化
   * readonly 可以在声明时，或者构造函数中进行初始化，不同的构造函数可以为 readonly 变量实现不同的初始值；在构造方法中，我们可以多次对 readonly 变量赋值
   * static readonly 变量的初始化，必须在定义时，或者静态无参构造函数中进行

4. 定义区别

   * const 可以定义字段和局部变量

   * readonly 则只能定义字段

     ```c#
     public class Person
     {
         //声明字段
         private const string name = "conren";
         
         public readonly int age = 24;
         
         private static readonly string address = "江苏苏州";
         
         public Person()
         {
             //readonly多次赋值
             age = 25;
             age = 26;
     
             //声明局部变量
             const string name = "kyson";
         }
     }
     ```

5. 语法外的最大区别

   * const 变量的值是 CLR 特殊处理嵌入在 IL 代码中，编译时就加载好，不依赖外部 dll（编译好后都可以删除这个外部 dll），所以在程序集更新时 const 容易产生版本不一致的情况
   * readonly 的变量是在运行时加载，需请求加载 dll，每次都获取最新的值，依赖外部 dll，不会出现版本不一致问题，更灵活，但是效率相较于 const 就低了一些

### 3.3.3 属性^（p61）^

#### 1. 自动实现的属性

`public int Age { get; set; }`

* 如果属性的 `set` 和 `get` 访问器中没有任何逻辑，就可以使用自动实现的属性

* 这种属性会自动实现后备成员变量

* 不能直接访问字段，因为不知道编译器生成的名称

* 不能在属性设置中校验属性的有效期

* 可以使用属性初始化器来初始化

  ```c#
  public class Student
  {
      public Student()
      {
          Console.WriteLine(Age);
      }
  
      public int Age { get; set; } = 42;
  }
  ```

  编译器将把这种初始化语句移动到创建的构造函数中，在构造函数体之前进行初始化

  ```c#
  public Student()
  {
  	Age = 42;
  	base..ctor();
  	Console.WriteLine(Age);
  }
  ```

#### 2. 属性的访问修饰符

* C# 允许给属性的 get 和 set 访问器设置不同的访问修饰符

* get 访问器没有任何访问修饰符，这表示 get 访问器采用属性的访问级别

  ```c#
      public int Age { get;private set; } = 42;
  
      private string _name;
      public string Name
      {
          get=> _name; 
          private set => _name = value;
      }
  ```

* 在 get 和 set 访问器中，必须有一个采用属性的访问级别

#### 4. 表达实体属性

```c#
  	private readonly string _firstName;
    public string FirstName => _firstName;

    private readonly string _lastName;
    public string LastName => _lastName;

    public string FullName => $"{FirstName} {LastName}";
```

* 对于**只实现了 get 访问器**的属性，可以借助 `=>` 符号使用一种简化的语法，为其赋值一个表达实体成员

* 在后台，编译器使用 get 访问器创建一个实现

  ```c#
  private readonly string _firstName;
  public string FirstName
  {
  	get
  	{
  		return _firstName;
  	}
  }
  ```

#### 5. 自动实现的只读属性

`public string Id { get; } = Guid.NewGuid().ToString();`

* 在后台，编译器会创建一个只读字段和一个属性，get 访问器可以访问这个字段

  ```c#
  private readonly string <Id>k__BackingField;
  
  public string Id
  {
  	get
  	{
  		return <Id>k__BackingField;
  	}
  }
  ```

* 初始化器的代码进入构造函数的实现代码，并在调用构造函数体之前调用

  ```c#
  public Student()
  {
  	Id = Guid.NewGuid().ToString();
  	base..ctor();
  }
  ```

* 只读属性也可以显示地在构造函数中初始化

  ```c#
  public class Book
  {
      public Book(string title) => Title = title;
      public string Title { get; }
  }
  ```

#### 6. 仅初始化的 set 访问器

`init` 访问器的属性只能在**构造函数内**或者使用**对象初始化器**来设置属性的值

```c#
public class Book
{
    public Book(string title)
    {
        Title = title;
    }

    public string Title { get; init; }
    public string? Publisher { get; init; }
}

Book theBook = new ("Professional C#") 
{ 
    Publisher = "Wrox Press" 
};
```

### 3.3.4 方法^（p64）^

#### 1. 方法的声明

对于没有返回值的情况，`return` 语句就是可选的，当到达闭花括号时，方法会自动返回

#### 2. 表达实体方法

如果方法的实现**只有一条语句**，C# 为方法定义提供了一个简化的语法

```c#
public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
```

#### 4. 方法的重载

* 方法的几个版本有不同的签名，即，**方法名相同，但参数的个数或数据类型不同**
* 一个重载的方法可以调用另一个重载的方法
* 仅通过返回类型不足以区分重载的版本，仅通过参数名称也不足以区分它们

#### 5. 命名的参数

```c#
public void MoveAndResize(int x, int y, int width, int height)

MoveAndResize(x: 10, width: 30, height: 40, y: 20);
```

用这种方式更改变量的顺序，编译器会重新安排，来获得正确的顺序

#### 6. 可选参数

```c#
public void TestMethod(int notOptionalNumber， int optionalNumber = 42)
{
    Console.WriteLine(optionalNumber + notOptionalNumber);
}

TestMethod(11);
TestMethod(11，42);
```

* 必须为可选参数提供默认值，可选参数必须是方法定义的最后的参数
* 传递一个参数时，编译器就修改方法调用，给第二个参数传递 42

#### 7. 个数可变的参数

```c#
public void AnyNumberOfArguments(params int[] data)
{
    foreach (var x in data)
    {
        Console.WriteLine(x);
    }
}

AnyNumberOfArguments(1);
AnyNumberOfArguments(1，3，57，11，13)
```

* 声明数组类型的参数(示例代码使用一个 `int` 数组)，并添加 `params` 关键字，就可以使用任意数量的 `int` 参数调用该方法
* 方法的参数类型是 `int[]` 所以可以传递一个 `int` 数组，或因为使用了 `params` 关键字，可以传递任何数量的 `int` 值
* 如果 `params` 关键字与方法签名定义的多个参数一起使用，则 `params` 只能使用一次，而且它必须是最后一个参数

==Warring：如果重载了方法，并且其中一个方法使用了 paramms 关键字，那么编译器会优先选择参数固定的方法，而不是使用 params 关键字的方法。例如，如果一个方法有两个int 参数(Foo(int,int))，另一个方法使用了 params 关键字(Foo(int[]params),那么在使用两个 int 实参调用该方法时，将调用 Foo(int,int)，因为它能够更好地匹配实参==

### 3.3.5 构造函数^（p68）^

```c#
public class MyClass
{
    public MyClass()
    {
    }
}
```

* 并不是必须给类提供构造函数。如果没有提供任何构造函数，编译器会在后台生成一个默认的构造函数。这个构造函数把所有的成员字段初始化为默认值（数字的默认值是 0，bool 的默认值是 false，引用类型的默认值是 null）
* 可以为构造函数提供任意多的重载，只要它们的签名有明显的区别即可
* 如果提供了任意构造函数，编译器就不会自动提供默认的构造函数

#### 1. 表达实体和构造函数

```c#
public class Singleton
{
    private Singleton(int state) => _state = state;
}
```

* 如果构造函数的实现由一个表达式组成，那么构造函数可以通过一个表达式体来实现

* 也可以使用一个表达式初始化多个属性（使用元组语法实现）

  ```c#
  public class Book
  {
      public Book(string title, string publisher) =>
          (Title, Publisher) = (title, publisher);
  
      public string Title { get; }
  
      public string Publisher { get; }
  }
  ```

  * `Book` 构造函数需要两个参数。将这两个变量放到圆括号内，就创建了一个元组，之后，这个元组被解构，放到赋值运算符左侧指定的属性中

#### 2. 从构造函数中调用其他构造函数

```c#
class Car
{
    private string _description;
    private int _speed;

    public Car(string description, int speed)
    {
        _description = description;
        _speed = speed;
    }

    public Car(string description) : this(description, 4)
    {
    }
}
```

* 这里，`this` 关键字仅调用参数最匹配的那个构造函数
* 构造函数初始化器在构造函数的函数体之前执行

#### 3. 静态构造函数

```c#
class MyClass
{
    static MyClass()
    {
    }
}
```

* 静态构造函数不能应用访问修饰符，因为它不是由使用该类的代码调用的
* `.NET` 运行库不保证什么时候执行静态构造函数，所以不能将依赖于静态构造函数在特定时间（例如加载程序集时）执行的代码放到静态构造函数中
* 无法预测不同类的静态构造函数按照什么顺序执行，但是，能够保静态构造函数最多只会运行一次，并且会在你的代码发出任何对类的引用之前调用，在 C# 中，通常在第一次调用该类的任何成员之前或者在创建任何实例之前，将自动调用静态构造函数

### 3.3.6 局部函数^（p70）^jub

```c#
public static void IntroLocalFunctions()
{
    int result = Add(3, 7);
    Console.WriteLine("called the local function with this result: {result}");

    static int Add(int x, int y) => x + y;
}
```

* 只能在声明了该局部函数的方法内调用，局部函数的作用域为该方法，所以不能从其他地方调用
* 可以为局部函数使用 `static` 修饰符，编译器会确保该局部函数不会访问实例成员或者方法的局部变量，并可以优化生成的代码
* 在使用局部函数的地方之前还是之后声明局部函数，只是个人偏好问题



```c#
public static void LocalFunctionWithClosure()
{
    int z = 3;

    int result = Add(1, 2);
    Console.WriteLine($"called the local function with this result: {result}")

    int Add(int x, int y) => x + y + z;
}
```

* 访问自己作用域外的变量(称为闭包)时，编译器会创建一个类，将这个函数内使用的数据传递给该类的构造函数

  * **实际反编译后的结果**

    ```c#
    private struct <>c__DisplayClass0_0
    {
    	public int z;
    }
    
    public static void LocalFunctionWithClosure()
    {
    	<>c__DisplayClass0_0 <>c__DisplayClass0_ = default(<>c__DisplayClass0_0);
    	<>c__DisplayClass0_.z = 3;
        
    	int result = <LocalFunctionWithClosure>g__Add|0_0(1, 2, ref <>c__DisplayClass0_);
    	Console.WriteLine($"called the local function with this result: {result}");
    }
    
    private static int <LocalFunctionWithClosure>g__Add|0_0(int x, int y, ref <>c__DisplayClass0_0 P_2)
    {
    	return x + y + P_2.z;
    }
    ```

* 对于这种情况，需要在声明局部函数内使用的变量后再声明该局部函数

### 3.3.8 扩展方法^（p71）^

```c#
public static class StringExtensions
{
    public static int GetWordCount(this string s) =>
        s.Split().Length;
}
```

* 扩展方法允许创建扩展其他类型的方法

* `GetWordCount()` 扩展了字符串类型，因为带有 `this` 修饰符的参数(这需要是第一个参数)是 `sting` 类型

* 扩展方法需要是静态方法，并且在一个静态类中声明

* 扩展方法只不过是语法糖，因为编译器会将方法调用改为调用一个静态方法，并传入该实例作为参数

  ```c#
  int wordCount = StringExtensions.GetWordCount(fox);
  ```

### 3.3.9 匿名类型^（p72）^

```c#
var captain = new
{
    FirstName = "James",
    MiddleName = "Tiberius",
    LastName = "Kirk"
};
```

* 匿名类型是从 `objet` 继承的一个没有名称的类

* 类的定义从初始化器中推断出，就像隐式类型的变量那样

* 这将生成一个包含 `FistName`，`MiddleName` 和 `LastName` **只读属性的对象**

* ```c#
  var doctor = new
  {
      FirstName = "James",
      MiddleName = "Tiberius",
      LastName = "Kirk"
  };
  ```

  * 那么 `captain` 和 `doctor` 的类型是相同的。可以设置 `captain = doctor`。只有当全部属性匹配时，才够这么做

* 如果使用另外一个对象设置匿名类型的成员的值，那么可以推断出这些成员的名称

  ```c#
  var captain = new
  {
      person.FirstName,
      person.MiddleName,
      person.LastName 
  };
  ```

* 匿名类型的实际类型名称是未知的，所以它们才被称为“匿名”类型

* 编译器会为这种类型编造个名称，但只有编译器能够使用该名称。因此，你不能也不应该计划在新对象上使用类型反射，因为这样做无法得到一致的结果

## 3.4 记录

编译器会实现按值比较记录的代码，并提供其他一些特性

### 3.4.1 不可变类型^（p73）^

* 记录的一种主要用例是创建不可变类型（不过使用记录也可以创建可变类型）
* 不可变类型只包含类型状态不能改变的成员，可以使用构造函数或者对象初始化器初始化这种类型，但之后就不能再改变任何值

### 3.4.2 名义记录^（p73）^

```c#
public record Book1
{
    public string Title { get; init; } = string.Empty;
    public string Publisher { get; init; } = string.Empty;
}
```

* 可以在记录中添加构造函数和其他所有成员
* 编译器会重写基类 `object` 的 `GetHashCode()` 和 `ToSting()` 方法，创建方法和运算符重载来比较不同的值的相等性，创建方法来克隆现有对象以及创建新对象，此时可以使用对象初始化器修改一些属性的值

### 3.4.2 位置记录^（p73）^

```c#
public record Book2(string Title, string Publisher);
```

* 这种语法在记录名称的后面使用圆括号指定成员

* 编译器也会根据这些代码生成一个类，并为主构造函数中使用的类型创建只能在初始化时设置的访问器，以及使用相同参数初给化属性的一个构造函数

  ```c#
  public string Title { get; init; }
  
  public string Publisher { get; init; }
  
  public Book2(string Title, string Publisher)
  {
  	this.Title = Title;
  	this.Publisher = Publisher;
  }
  ```

* 通过使用花括号，可以在现有实现中添加需要的东西，例如重载的构造函数、方法或者其他成员

  ```c#
  public record Book2(string Title, string Publisher)
  {
      public Book2(string title) : this(title, "")
      {
      }
  }
  ```

### 3.4.4 记录的相等性比较^（p74）^

* 类对于相等性比较的默认实现是比较引用，而记录对于相等比较的实现是，如果两个记录的属性值相同，那么它们就相等
* 记录类型使用 `Equals()` 方法实现了 `IEquality` 接口，还实现了 `==`（相等）和 `!=`（不相等）运算符

### 3.4.5 with 表达式^（p74）^

* 使用记录语法创建的代码包含一个拷贝构造函数和一个有隐藏名称的 `Clone()` 方法，该方法可以将现有象的全部值复制到它返回的新实例中。`with` 表达式使用这个 `Clone()` 方法

* 再结合只能在初始化时置的访问器，就可以使用对象初始化语法来设置应该不同的值

  ```c#
  var aNewBook = bookla with ( Title = "Professional C# and .NET - 2024");
  ```

## 3.5 结构^（p75）^

```c#
public readonly struct Dimensions
{
    public double Length { get; }
    public double Width { get; }

    public Dimensions(double length, double width)
    {
        Length = length;
        Width = width;
    }
}
```

* 为了减少垃圾收集器需要做的工作，可以为较小的对象使用栈
* 默认存储在栈上，而不是堆上
* 如果结构的成员不修改任何状态(构造函数除外)，那么可以使用 `readonly` 修饰符声明结构。编译器会确保你不能添加任何修改状态的成员
* 结构采用前面讨论过的按值传递语义，即值会被复制

### 结构与类和记录还有其他区别:

1. 结构不支持继承，可以使用结构实现接口，但不能继承另外一个结构
2. 结构总是有一个默认的构造函数。对于类，如果定义了构造函数，则不会再生成默认构造函数。结构类型与类不同。结构总是有一个默认构造函数，你无法创建一个自定义的无参数构造函数
   * ==使用 C# 10，您可以为结构体创建一个自定义的无参数构造函数==
3. 对于结构，可以指定字段在内存中如何布局
4. 结构存储在栈上，或者如果结构是堆上存储的另外一个对象的一部分，就会内联存储它们

## 3.6 枚举类型^（p76）^

```c#
public enum Color
{
	Red，
	Green，
	Blue
}
```

* 枚举是一个**值类型**，包含一组命名的常量

* 默认情况下，`enum` 的类型是 `int`

* 命名常量的值从 0 开始递增，但它们可以改为其他值

  ```c#
  public enum Color : short
  {
      Red = 1,
      Green = 2,
      Blue = 3
  }
  ```

* `Flags` 特性告诉编译器，为值创建一个不同的字符串表示，例如给 `DaysOfWeek` 类型的一个变量设置值 3，如果为 `DaysOfWeek` 枚举使用了 `Flags` 特性，那么结果是 `Monday`,`Tuesday`

  ```c#
  [Flags]
  public enum DaysOfWeek
  {
      Monday = 0x1,
      Tuesday = 0x2,
      Wednesday = 0x4,
      Thursday = 0x8,
      Friday = 0x10,
      Saturday = 0x20,
      Sunday = 0x40,
  }
  
  DaysOfWeek mondayAndTuesday = (DaysOfWeek)3;
  Console.WriteLine(mondayAndTuesday);
  ```

  > Monday, Tuesday 

  * 有了这个枚举声明，就可以使用“逻辑或”运算符为一个变量指定多个值

    ```c#
     DaysOfWeek mondayAndWednesday = DaysOfWeek.Monday | DaysOfWeek.Wednesday;
     Console.WriteLine(mondayAndWednesday);
    ```

    > Monday, Wednesday
  
  * 设置不同的位时，也可以通过组合位来包括多个值，如 `Weekend` 的值 0x60 是用“逻辑或”运算符组合了 `Saturday` 和 `Sunday` 的结果
  
    ```c#
    Weekend = Saturday | Sunday,
    Workday = 0x1f,
    AllWeek = Workday | Weekend,
    
    DaysOfWeek weekend = DaysOfWeek.Saturday | DaysOfWeek.Sunday;
    Console.WriteLine(weekend);
    ```
  
    > Weekend

* 使用枚举时，类 `Enum` 有时非常有助于**动态获得枚举类型的信息**

  ```c#
  if (Enum.TryParse<Color>("Red", out Color red))
  {
      Console.WriteLine($"successfully parsed {red}");
  }
  
  string? redtext = Enum.GetName(typeof(Color), red);
  Console.WriteLine(redtext);
  
  foreach (var day in Enum.GetNames(typeof(Color)))
  {
      Console.WriteLine(day);
  }
  
  foreach (short val in Enum.GetValues(typeof(Color)))
  {
      Console.WriteLine(val);
  }
  
  foreach (var item in Enum.GetValues(typeof(Color)))
  {
      Console.WriteLine(item);
  }
  ```

  > successfully parsed Red
  >
  > Red
  >
  > Red
  > Green
  > Blue
  >
  > 1
  > 2
  > 3
  >
  > Red
  > Green
  > Blue

## 3.7 ref,in 和 out

* 值类型是按值传递的，所以当把一个变量赋值给另外一个变量时，例如将变量传递给方法时，复制该变量的值
* 如果使用 `ref` 关键字，将按引用传递值类型

### 3.7.1 ref 参数

```c#
int a = 1;
ChangeAValueType(ref a);
Console.WriteLine($"the value of a changed to {a}");

void ChangeAValueType(ref int x)
{
    x = 2;
}
```

> the value of a changed to 2

* 使用 `ref` 关键字时，需要在**调用方法前先初始化参数**

* 因为使用了 `ref` 修饰符，所以会按引用传递 `int`(使用 `int` 变量的地址)

* 在实现中，现在名为 x 的变量用的是与变量 a 相同的、栈上的数据。修改变量 x 的值也会修改 a 的值，所以在调用后，变量 a 包含的值是 2

* 如果想按引用传递值类型，需要在**声明方法时和调用方法时都使用 `ref` 关键字**

* 使用 `ref` 关键字传递引用，将**传递指针的指针**

  ```c#
  SomeData data1 = new() { Value = 1 };
  ChangingAReferenceByRef(ref data1);
  Console.WriteLine($"the new value of data1.Value is: {data1.Value}");
  
  void ChangingAReferenceByRef(ref SomeData data)
  {
      data.Value = 2;
      data = new SomeData { Value = 3 };
  }
  
  class SomeData
  {
      public int Value { get; set; }
  }
  ```

  > the new value of data1.Value is: 3

### 3.7.2 in 参数

```c#
void PassValueByReferenceReadonly(in SomeValue data)
{
    data.Value1 = 4;// - you cannot change a value, it's a read-only variable!
}

struct SomeValue
{
    public SomeValue(int value1, int value2, int value3, int value4)
    {
        Value1 = value1;
        Value2 = value2;
        Value3 = value3;
        Value4 = value4;
    }
    public int Value1 { get; set; }
    public int Value2 { get; set; }
    public int Value3 { get; set; }
    public int Value4 { get; set; }
}
```

* 如果在向方法**传递一个值类型时，想要避免复制值的开销，但又不想在方法内改变值**，就可以使用 `in` 修饰符
* 使用 `in` 修饰符时，会采用**按引用传递，但编译器不允许在使用 `data` 变量时修改任何值**

### 3.7.3 ref return

```c#
ref SomeValue Max(ref SomeValue x, ref SomeValue y)
{
    int sumx = x.Value1 + x.Value2 + x.Value3 + x.Value4;
    int sumy = y.Value1 + y.Value2 + y.Value3 + y.Value4;

    //if (sumx > sumy)
    //{
    //    return ref x;
    //}
    //else
    //{
    //    return ref y;
    //}

    ref SomeValue r = ref (sumx > sumy) ? ref x : ref y;
    return ref r;
}
```

* 为了**避免在方法返回时复制值**，可以在声明返回类型时添加 `ref` 关键字，并在返回值时使用 `return ref`

* 调用者需要决定是应该复制返回的值，还是应该使用引用

  ```c#
  SomeValue one = new SomeValue(1, 2, 3, 4);
  SomeValue two = new SomeValue(5, 6, 7, 8);
  
  //复制返回值
  SomeValue bigger1 = Max(ref one, ref two);
  
  ref SomeValue bigger2 = ref Max(ref one, ref two);
  
  ref readonly SomeValue bigger3 = ref Max(ref one, ref two);
  ```

* `Max` 方法不会修改它的任何输入，这就允许为参数使用 `in` 关键字，但是，这里必须把返回类型的声明改为 `ref readonly`，如果不这么做，将允许 `MaxReadonly` 方法的调用者在收到结果后改变该方法的输入

  ```c#
  ref readonly SomeValue bigger4 = ref MaxReadonly(in one, in two);
  //复制返回值
  SomeValue bigger5 = MaxReadonly(in one, in two);
  
  ref readonly SomeValue MaxReadonly(in SomeValue x, in SomeValue y)
  {
      int sumx = x.Value1 + x.Value2 + x.Value3 + x.Value4;
      int sumy = y.Value1 + y.Value2 + y.Value3 + y.Value4;
  
      return ref (sumx > sumy) ? ref x : ref y;
  }
  ```

### 3.7.4 out 参数

```c#
bool TryParse(string? s, out int result);

Console.Write("Please enter a number: ");
string? input = Console.ReadLine();
if (int.TryParse(input, out int x))
{
    Console.WriteLine();
    Console.WriteLine($"read an int: {x}");
}
```

* 如果方法只应该返回数据，可以使用 `out` 关键字
* 使用 `out` 修饰符时，不需要在调用 `TryParse()` 方法前声明或者初始化该变量

## 3.8 元组

* 元组允许把**不同类型的多个对象组合为一个对象**，但又没有创建自定义类型时的复杂性
* 使用 `ref` 和 `out` 关键字有一个重要的限制:它们**不能用于异步方法**

### 3.8.1 声明和初始化元组

```c#
(string AString, int Number, Book Book) tuple =
    ("magic", 42, new Book("Professional C#", "Wrox Press"));

Console.WriteLine($"a string: {tuple.AString}, number: {tuple.Number}, book: {tuple.Book}");
```

> a string: magic, number: 42, book: Book { Title = Professional C#, Publisher = Wrox Press }

* 可以使用圆括号声明元组，然后使用在圆括号内创建的元组字面值来初始化该元组

* 使用元组指定的名称是公有成员，而公有成员通常使用 `PascalCase` 命名法

* 在把元组字面值赋值给元组变量的时候，也可以不声明其成员

  ```c#
  var tuple2 = ("magic", 42, new Book("Professional C#", "Wrox Press"));
  Console.WriteLine($"aString: {tuple2.Item1}, number: {tuple2.Item2}, book: {tuple2.Item3}");
  ```

* 在字面值中，可以为元组字段分配名称，这需要首先定义一个名称，其后跟上一个冒号

  ```c#
  var tuple3 = (AString: "magic", Number: 42, Book: new Book("Professional C#", "Wrox Press"));
  Console.WriteLine($"aString: {tuple3.AString}, number: {tuple3.Number}, book: {tuple3.Book}");
  ```

* 名称只是提供一种便利。当类型匹配的时候，可以把一个元组赋值给另一个元组，名称并不重要

  ```c#
  (string S, int N, Book B) tuple4 = tuple3;
  ```

* 元组成员的名称也可以从源推断出来

  ```c#
  Book book = new("Professional C#", "Wrox Press");
  var tuple5 = (ANumber: 42, book.Title);
  Console.WriteLine(tuple5.Title);
  ```

### 3.8.2 元组解构

```c#
var tuple1 = (AString: "magic", Number: 42, Book: new Book("Professional C#", "Wrox Press"));
(string aString, int number, Book book) = tuple1;

Console.WriteLine($"a string: {aString}, number: {number}, book: {book}");

// use discard
(_, _, var book1) = tuple1;
Console.WriteLine(book1.Title);
```

* 可以将**元组解构为变量**

### 3.8.3 元组的返回

```c#
(int result, int remainder) = Divide(7, 2);
Console.WriteLine($"7 / 2 - result: {result}, remainder: {remainder}");

(int result, int remainder) Divide(int dividend, int divisor)
{
    int result = dividend / divisor;
    int remainder = dividend % divisor;
    return (result, remainder);
}
```

* 使用元组，可以避免通过 `out` 参数声明方法签名。`out` 参数不能与 `async` 方法一起使用，但此限制不适用于元组

## 3.9 ValueTuple

```c#
(string AString, int Number, Book Book) tuple =
    ("magic", 42, new Book("Professional C#", "Wrox Press"));
Console.WriteLine($"a string: {tuple.AString}, number: {tuple.Number}, book: {tuple.Book}");

ValueTuple<string, int, Book> tuple = 
    new ValueTuple<string, int, Book>("magic", 42, new Book("Professional C#", "Wrox Press"));
Console.WriteLine($"a string: {tuple.Item1}, number: {tuple.Item2}, book: {tuple.Item3}");
```

* 使用 `C#` 元组语法时，`C#` 编译器在后台创建 `ValueTuple` 结构
* ~~使用元组字面值会调用 `Tuple.Create()`~~
* `ValueTuple` 定义了名为 `Item1`,`Item2`,`Item3` 等的公有字段，以访问所有项
* 对于元素的名称，编译器使用 `TupleElemenNames` 特性来存储元组成员的自定义名称。编译器将读取这些信息来调用正确的成员

## 3.10 解构

```c#
public void Deconstruct(out string firstName, out string lastName, out int age)
{
    firstName = FirstName;
    lastName = LastName;
    age = Age;
}
```

* 可以对任意自定义类型进行解构：把类或 解构分解为它的各个部分

* 为完成解构，只需要创建 `Deconstruct()` 方法(也被称为解构器)，将分离的部分放入 `out` 参数中

* 解构是用方法 `Deconstruct()` 实现的（**可重载**）。该方法总是 `void` 类型，并用 `out` 参数返回各个部分

* 还可以通过创建**扩展方法来进行解构**

  ```c#
  public static class PersonExtensions
  {
      public static void Deconstruct(this Person person, out string firstName,
          out string lastName, out int age)
      {
          firstName = person.FirstName;
          lastName = person.LastName;
          age = person.Age;
      }
  }
  ```

## 3.11 模式匹配

### 3.11.1 使用元组进行模式匹配

模式匹配可以基于**元组的值**

```c#
(TrafficLight Current, TrafficLight Previous) NextLightUsingTuples(TrafficLight current, TrafficLight previous) =>
    (current, previous) switch
    {
        (Red, _) => (Amber, current),
        (Amber, Red) => (Green, current),
        (Green, _) => (Amber, current),
        (Amber, Green) => (Red, current),
        _ => throw new InvalidOperationException()
    };
```

### 3.11.2 属性模式

```c#
TrafficLightState NextLightUsingRecords(TrafficLightState trafficLightState) =>
    trafficLightState switch
    {
        { CurrentLight: AmberBlink } => new TrafficLightState(Red, trafficLightState.PreviousLight, 3000),

        { CurrentLight: Red } => new TrafficLightState(Amber, trafficLightState.CurrentLight, 200),

        { CurrentLight: Amber, PreviousLight: Red } => new TrafficLightState(Green, trafficLightState.CurrentLight, 2000),

        { CurrentLight: Green } => new TrafficLightState(GreenBlink, trafficLightState.CurrentLight, 100, 1),

        { CurrentLight: GreenBlink, BlinkCount: < 3 } => trafficLightState with { BlinkCount = trafficLightState.BlinkCount + 1 },

        { CurrentLight: GreenBlink } => new TrafficLightState(Amber, trafficLightState.CurrentLight, 200),

        { CurrentLight: Amber, PreviousLight: GreenBlink } => new TrafficLightState(Red, trafficLightState.CurrentLight, 3000),

        _ => throw new InvalidOperationException()
    };
```

## 3.12 分部类型

```c#
//SampleClassAutogenerated.cs
partial class SampleClass
{
    public void MethodOne() { }
}

//SampleClass.cs
partial class SampleClass
{
    public void MethodTwo() { }
}
```

* `partial` 关键字允许把**一个类型放在多个文件中**
* `partial` 关键字的用法是:把 `partial` 放在 `class`、`strut` 或 `interface` 关键字的前面
* 当编译包含这两个源文件的项目时，会创建一个 `SampleClass` 类，它有两个方法 `MethodOne()` 和 `MethodTwo()`
* 在把分部类型编译为类型时，**特性、XML 注释、接口、泛型参数特性和成员会合并**
* 尽管创建庞大的类，使其分散到不同的文件中，然后让不同开发人员在不同的文件中开发相同的类看起来很有诱惑力，但 `patial` 关键字并不是为这种目的设计的。在这种情况下，最好把大类拆分几个小类，**一个类只用于一个目的**

### 分部方法

```c#
//SampleClassAutogenerated.cs
partial class SampleClass
{
    public void MethodOne()
    {
        APartialMethod();
    }

    public partial void APartialMethod();
}
//SampleClass.cs
partial class SampleClass
{
    public partial void APartialMethod()
    {

    }
}
```

* 分部类可以包含分部方法。如果生成的代码应该**调用可能不存在的方法**，这就是非常有用的
* `APartialMethod()` 方法用 `partial` 关键字明，因此不需要任何实现代码。**如果没有实现代码，编译器将删除这个方法调用**
* 分部方法的实现可以放在分部类的其他任何地方
* 在 `C#9` 之前，分部方法必须被声明为 `void` 类型。现在不再需要这么做。但是，如果分部方法不返回 `void`，就必须提供实现

# 第四章 C# 面向对象编程

## 4.1 面向对象

* 面向对象的三个最重要的概念是**继承**、**封装**和**多态性**

## 4.2 类的继承

### 4.2.1 虚方法

* 把一个基类方法声明为 `virtual`，就可以在任何派生类中重写该方法

* 虚方法可以声明为 `public` 或 `protected`。在派生类中重写该方法时不能改变访问修饰符

* 也可以将属性声明为 `virtual`，`public virtual Size Size ( get; set;}`

* 要声明一个重写基类方法的方法，需要使用 `overide` 关键字

* 虚函数提供了 `OOP` 的一种核心特性:多态性

* 使用虚函数时，将调用哪个方法的决定推迟到了运行时。编译器会创建一个虚方法表(`virtualmethodtable vtable`)，其中列举了可在运行时调用的方法然后在运行时根据类型调用方法

* 在 `C#9` 之前，要求在重写基类的方法时,签名(所有参数类型和方法名)和返回类型必须精确匹配，如果想要使用不同的参数，需要创建一个不重写基类成员的新方法

  * 在 `C# 9` 中，这个规则有了一点小改变:重写方法时，返回类型可以不同，但需要**派生自基类的返回类型**

    ```c#
    public class Shape
    {
        public virtual Shape Clone() => throw new NotImplementedException();
    }
    
    public class Rectangle : Shape
    {
        public override Rectangle Clone()
        {
            return new Rectangle();
        }
    }
    ```

* 成员字段和静态方法都不能被声明为 `virtual`，除了实例函数成员之外，虚成员的概念没有意义

### 4.2.2 隐藏方法

```c#
public class Shape
{
    public void MoveBy()
    {
        Console.WriteLine($"{nameof(Shape)}正在移动");
    }
}

public class Ellipse : Shape
{
    new public void MoveBy()
    {
        Console.WriteLine($"{nameof(Ellipse)}正在移动");
    }
}
```

* 如果在基类和派生类中声明了签名相同的方法，但没有把该方法分别声明为 `virtual` 和 `override`，派生类方法就会隐藏基类方法
* 要隐藏方法，可以在方法声明中使用 `new` 关键字作为修饰符
* 编译器在有和没有 `new` 修饰符时候创建的代码是相同的，但是使用 `new` 修饰符能够消除编译警告
* `new` 方法修饰符不应该故意用于隐藏基类的成员

### 4.2.3 调用方法的基类版本

* 如果派生类重写或者隐藏了基类的方法，则可以使用 `base` 关键字来调用该方法的基类版本
* 使用 `basc` 关键字，可以调用基类的任何方法，而不仅仅是已重写的方法

### 4.2.4 抽象类和抽象方法

```c++
public abstract class Shape
{
    public abstract Shape Clone();
}
```

* `C#` 允许把类和方法声明为 `abstact`，抽象类**不能实例化**，而抽象方法**没有实现**，必须在非抽象的派生类中重写
* 抽象类可以包含**抽象成员和非抽象成员**
* 如果类包含抽象方法，则该类也是抽象的，且必须声明为抽象的
* 从抽象基类中派生类型时，如果该派生类型不是抽象的，则是具体类型。具体类必须实现基类的所有抽象成员

### 4.2.5 密封类和密封方法

```c#
sealed class FinalClass
{
}

class DerivedClass: FinalClass  //wrong. Cannot derive from sealed class
{
}
```

* 给类添加 `sealed` 修饰符，就不允许创建该类的子类。密封一个方法，就不能重写该方法

* 对于密封类，编译器知道不能派生类，因此用于虚方法的虚拟表可以缩短或消除，以提高性能

* 要在方法或属性上使用 `sealed` 关键字，必须先从基类重写该成员

  ```c#
  public class Shape
  {
      public virtual Shape Clone()
      {
          throw new NotImplementedException();
      }
  }
  
  public class Circle : Shape
  {
      public sealed override Circle Clone()
      {
          throw new NotImplementedException();
      }
  }
  ```

### 4.2.6 派生类的构造函数

```c#
public class Parent
{
    public Parent(int age,string name)
    {
    }
}
public class Child : Parent
{
    public Child(int age, string name) : base(age, name)
    {
    }
}
```

## 4.3 修饰符

* 可用于类型或成员的关键字
* 修饰符可能说明方法的可见性，如 `public` 或 `private`，也可能说明项的性质，如方法是 `virtual` 或 `abstract`

### 4.3.1 访问修饰符

|              修饰符              |          应用于          |                             说明                             |
| :------------------------------: | :----------------------: | :----------------------------------------------------------: |
|              public              |      所有类型或成员      |                     任何代码均可访问该项                     |
|            protected             | 类型和嵌套类型的所有成员 |           只有该类型或者该类型的派生类型能访问该项           |
|             internal             |      所有类型或成员      |                只能在包含它的程序集中访问该项                |
|             private              | 类型和嵌套类型的所有成员 |                 只能在它所属的类型中访问该项                 |
| protected internal（famorassem） | 类型和嵌套类型的所有成员 |      只能在包含它的程序集或派生类型的任何代码中访问该项      |
| private protected（famandassem） | 类型和嵌套类型的所有成员 | 只能在包含它的类型和该类型的派生类型(必须在同一个程序集内)中访问该项 |

* 访问修饰符决定了其他哪些代码项可以访问某个代码项
* 如果没有为类型指定访问修饰符，则默认情况下使用 `intenal` 访问修饰符

#### protected

```c#
Child c = new Child();
//Parent.Age不可访问，因为它具有一定的保护级别
c.Age = 20;

class Parent
{
    protected int Age { get; set; }

    private void ChangeAge()
    {
        Age = 20;
    }
}

class Child : Parent
{
    public void PrintAge()
    {
        Console.WriteLine(Age);
    }
}
```

#### protected internal

* 它通过 `Or` 关系把 `protected` 和 `internal` 组合了起来，相同程序集内的任何类型都可以使用 `protected internal` 成员，而如果使用了继承关系，则另外一个程序集中的类型也可以使用这些成员
* 在中间语言代码中，这被称为 `famorassen`（`family or assembly`，家族或程序集），`family` 对应于 `C#` 的 `protected` 关键字，`assembly` 对应于 `internal` 关键字

#### private protected

* `famandassem` 也是可用的，将程序集内的访问权限限制为具有继承关系的类型，不允许其他任何程序集中的类型进行访问

### 4.3.2 其他修饰符

* 该表中的修饰符可以应用于类型的成员，而且有不要的用途
* 在应用于类型时，其中的几个修饰符也是有意义的

|  修饰符  |       应用于        |                             说明                             |
| :------: | :-----------------: | :----------------------------------------------------------: |
|   new    |      函数成员       |                成员用相同的签名隐藏继承的成员                |
|  static  |      所有成员       |    成员不做用于类的具体实例，也成为类成员，而不是实例成员    |
| virtual  |     仅函数成员      |                     成员可以由派生类重写                     |
| abstract |     仅函数成员      |        虚拟成员，定义了成员的签名，但没有提供实现代码        |
| override |     仅函数成员      |                成员重写了继承的虚拟或抽象成员                |
|  sealed  |   类、方法和展性    | 对于类，不能继承自密封类。对于属性和方法，成员重写已继承的虚拟成员，但任何派生类中的任何成员都不能重写该成员。此时，该修饰必须与 override 一起使用 |
|  extem   | 仅静态[DIlImport]方 |                                                              |

