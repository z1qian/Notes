# 测试

## 单元测试

* `.NET CLI` 对创建和运行单元测试提供了内置支持：
  1. `dotnet new mstest` 使用 `MSTest` 创建单元测试
  2. `dotnet new nunit` 使用 `NUnit` 创建单元测试
  3. `dotnet new xunit` 使用 xUnit.net 创建单元测试
* 由于 `.NET` 和 `ASPNET Core` 团队使用了 `xUnit.net`，所以本书中也将使用 `xUnit.net` 来构建测试项目

### 创建单元测试

* 测试项目的名称是在项目名后加上 `Tests`，例如，对于项目 `UnitTestingSamples`，测试项目的名称是 `UnitTestingSamples.Tests`

* 测试类名与被测试的类名相同，后跟 `Test`，例如，`UnitTestingSamplesDeepThought` 的测试类是 `UnitTestingSamples.DeepThoughtTest`

* 单元测试方法名采用描述性的名称，例如，名称 `AddOrUpdateBookAsync_ThrowsForNull` 表示，一个单元测试调用 `AddOrUpdateBookAsync()` 方法，检查传递 `null` 时它是否抛出异常

* 使用 `xUnit.net` 时，需要使用 `Fact`  特性来标记测试方法

  ```c#
  public class DeepThoughtTest
  {
      [Fact]
      public void ResultOfTheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything()
      {
          // arrange
          int expected = 42;
          var dt = new DeepThought();
  
          // act
          int actual =
            dt.TheAnswerToTheUltimateQuestionOfLifeTheUniverseAndEverything();
  
          // assert
          Assert.Equal(expected, actual);
      }
  }
  ```

  * 单元测试由 3 个 A 定义：`Arrange`（安排，准备），`Act`（行动，调用被测试方法） 和 `Assert`（断言，验证结果）


### 运行单元测试

* .NET CLI：`dotnet test`

### 测试全部代码路径

* 定义一个带参数的测试方法，并使用特性传递不同的值。为此，需要对测试方法应用 `Theory` 特性，而不是 `Fat` 特性。可以使用多个定义值的  `InlineData` 特性来传递数据，有了这些特性，测试运行器可以多次调用 `GetStringDemolnlineData()` 方法并为每个 `InlineData` 特性传递值

  ```c#
  [Theory]
  [InlineData("", "a", "b", "b not found in a")]
  [InlineData("", "longer string", "nger", "removed nger from longer string: lo string")]
  [InlineData("init", "longer string", "string", "INIT")]
  public void GetStringDemoInlineData(string init, string a, string b, string expected)
  {
      StringSample sample = new(init);
      string actual = sample.GetStringDemo(a, b);
      Assert.Equal(expected, actual);
  }
  ```

* 还可以定义一个方法来返回要传递给测试方法的值，并使用 `MemberData` 特性指定方法的名称

  ```c#
   [Theory]
   [MemberData(nameof(GetStringSampleData))]
   public void GetStringDemoMemberData(string init, string a, string b, string expected)
   {
       StringSample sample = new(init);
       string actual = sample.GetStringDemo(a, b);
       Assert.Equal(expected, actual);
   }
  
   public static IEnumerable<object[]> GetStringSampleData() =>
       new[]
       {
               new object[] { "", "a", "b", "b not found in a" },
               new object[] { "init", "longer string", "string", "INIT" },
               new object[] { "", "longer string", "nger", "removed nger from longer string: lo string" }
       };
  ```
